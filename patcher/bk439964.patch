diff --git a/usr/src/minix/include/minix/callnr.h b/usr/src/minix/include/minix/callnr.h
index 6030687..a543d38 100644
--- a/usr/src/minix/include/minix/callnr.h
+++ b/usr/src/minix/include/minix/callnr.h
@@ -118,7 +118,9 @@
 #define VFS_COPYFD		(VFS_BASE + 46)
 #define VFS_CHECKPERMS		(VFS_BASE + 47)
 #define VFS_GETSYSINFO		(VFS_BASE + 48)
+#define VFS_EXCLUSIVE		(VFS_BASE + 49)
+#define VFS_FEXCLUSIVE		(VFS_BASE + 50)
 
-#define NR_VFS_CALLS		49	/* highest number from base plus one */
+#define NR_VFS_CALLS		51	/* highest number from base plus one */
 
 #endif /* !_MINIX_CALLNR_H */
diff --git a/usr/src/minix/include/minix/ipc.h b/usr/src/minix/include/minix/ipc.h
index 622c40d..641ab12 100644
--- a/usr/src/minix/include/minix/ipc.h
+++ b/usr/src/minix/include/minix/ipc.h
@@ -841,6 +841,16 @@ typedef struct {
 } mess_lc_vfs_umount;
 _ASSERT_MSG_SIZE(mess_lc_vfs_umount);
 
+typedef struct {
+	int fd;
+	vir_bytes name;
+	size_t len;
+	int flags;
+
+	uint8_t padding[40];
+} mess_lc_vfs_exclusive;
+_ASSERT_MSG_SIZE(mess_lc_vfs_exclusive);
+
 typedef struct {
 	void		*addr;
 	uint8_t		padding[52];
@@ -2121,6 +2131,7 @@ typedef struct {
 		mess_lc_vfs_truncate	m_lc_vfs_truncate;
 		mess_lc_vfs_umask	m_lc_vfs_umask;
 		mess_lc_vfs_umount	m_lc_vfs_umount;
+		mess_lc_vfs_exclusive	m_lc_vfs_exclusive;
 		mess_lc_vm_brk		m_lc_vm_brk;
 		mess_lc_vm_getphys	m_lc_vm_getphys;
 		mess_lc_vm_rusage	m_lc_vm_rusage;
diff --git a/usr/src/sys/sys/fcntl.h b/usr/src/sys/sys/fcntl.h
index 6caaf29..65095df 100644
--- a/usr/src/sys/sys/fcntl.h
+++ b/usr/src/sys/sys/fcntl.h
@@ -301,6 +301,13 @@ struct flock {
 #define	AT_REMOVEDIR		0x800	/* Remove directory only */
 #endif
 
+/*
+ * Constants for exclusive lock.
+ */
+#define EXCL_UNLOCK				1	/* Unlock. */
+#define EXCL_UNLOCK_FORCE		2	/* Forced unlock by privileged users. */
+#define EXCL_LOCK				4	/* Lock unconditionally. */
+#define EXCL_LOCK_NO_OTHERS		8	/* Lock if no other users have this file opened. */
 
 #ifndef _KERNEL
 #include <sys/cdefs.h>
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/const.h fake_mount/usr/src/minix/servers/vfs/const.h
--- old_mount/usr/src/minix/servers/vfs/const.h	2023-06-15 20:02:39.805608345 +0200
+++ fake_mount/usr/src/minix/servers/vfs/const.h	2023-06-17 21:31:18.725731979 +0200
@@ -7,6 +7,7 @@
 #define NR_MNTS           16 	/* # slots in mount table */
 #define NR_VNODES       1024	/* # slots in vnode table */
 #define NR_WTHREADS	   9	/* # slots in worker thread table */
+#define NR_EXCLUSIVE	8	/* # slots in the exclusive locking table */
 
 #define NR_NONEDEVS	NR_MNTS	/* # slots in nonedev bitmap */
 
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/excl_lock.h fake_mount/usr/src/minix/servers/vfs/excl_lock.h
--- old_mount/usr/src/minix/servers/vfs/excl_lock.h	1970-01-01 01:00:00.000000000 +0100
+++ fake_mount/usr/src/minix/servers/vfs/excl_lock.h	2023-06-18 10:03:15.795250468 +0200
@@ -0,0 +1,22 @@
+#ifndef __VFS_EXCL_LOCK_H__
+#define __VFS_EXCL_LOCK_H__
+
+/* This is the exclusive lock table.
+ * Slot free if vp == NULL.
+ */
+
+#include "const.h"
+
+EXTERN struct excl_lock {
+  struct vnode* vp;
+  int fd;
+  pid_t caller_p;
+  uid_t owner;
+  int info;
+} excl_lock[NR_EXCLUSIVE];
+
+#define EXCL_BY_FD        1 /* file locked by VFS_FEXCLUSIVE */
+#define EXCL_BY_PATH      2 /* file locked by VFS_EXCLUSIVE */
+#define EXCL_MOVED        4 /* file moved after VFS_EXCLUSIVE lock */
+
+#endif
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/exclusive.c fake_mount/usr/src/minix/servers/vfs/exclusive.c
--- old_mount/usr/src/minix/servers/vfs/exclusive.c	1970-01-01 01:00:00.000000000 +0100
+++ fake_mount/usr/src/minix/servers/vfs/exclusive.c	2023-06-18 09:57:21.594188624 +0200
@@ -0,0 +1,117 @@
+#include "excl_lock.h"
+#include "const.h"
+#include "fs.h"
+#include "glo.h"
+#include "vnode.h"
+#include "fproc.h"
+#include <asm-generic/errno-base.h>
+#include <minix/endpoint.h>
+#include <sys/types.h>
+#include <sys/fcntl.h>
+#include <stdio.h>
+
+#define OK 0
+#define NOT_OK -1
+
+/* extracted message values */
+uid_t caller;
+struct vnode* vp;
+int fd, flags, info;
+
+struct excl_lock* lc;
+
+int get_free_excl_lock(void) {
+	for (int i = 0; i < NR_EXCLUSIVE; i++)
+		if (excl_lock[i].vp == NULL) {
+			lc = &excl_lock[i];
+			return OK;
+		}
+	return NOT_OK;
+}
+
+int find_excl_lock(void) {
+	for (int i = 0; i < NR_EXCLUSIVE; i++)
+		if (excl_lock[i].vp == vp) {
+			lc = &excl_lock[i];
+			return OK;
+		}
+	return NOT_OK;
+}
+
+int check_for_other_users(void) {
+	for (int i = 0; i < NR_PROCS; i++)
+		for (int j = 0; j < OPEN_MAX; i++)
+			if (fproc[i].fp_realuid == caller &&
+				fproc[i].fp_flip[j] != NULL &&
+				fproc[i].fp_flip[j].filp_vp == vp)
+			{
+				return NOT_OK;
+			}
+	return OK;
+}
+
+int do_locking(void) {
+	if (find_excl_lock() != NOT_OK)
+		return EALREADY;
+	if (get_free_excl_lock() != OK)
+		return ENOLCK;
+	
+	lc->vp = vp;
+	lc->owner = caller;
+	lc->caller_p = who_p;
+	lc->fd = fd;
+	lc->info = info;
+}
+
+int do_common(void) {
+	switch (flags) {
+		case EXCL_LOCK:
+			return do_locking();
+		case EXCL_LOCK_NO_OTHERS:
+			if (check_for_other_users() != OK)
+				return EAGAIN;
+			return do_locking();
+		case EXCL_UNLOCK:
+			if (find_excl_lock() != OK)
+				return EINVAL;
+			if (caller != lc->owner)
+				return EPERM;
+			lc->vp = NULL;
+		case EXCL_UNLOCK_FORCE:
+			if (find_excl_lock() != OK)
+				return EINVAL;
+			if (caller != lc->owner && caller != SU_UID)
+				return EPERM;
+			lc->vp = NULL;
+		default:
+			return EINVAL;
+	}
+
+	return OK;
+}
+
+int do_exclusive(void) {
+	caller = fp->fp_realuid;
+
+	return EPERM;
+}
+
+int do_fexclusive(void) {
+	caller = fp->fp_realuid;
+	fd = job_m_in.m_lc_vfs_exclusive.fd;
+	flags = job_m_in.m_lc_vfs_exclusive.flags;
+	info = EXCL_BY_FD;
+
+	if (fd < 0 || fd >= OPEN_MAX)
+		return EBADF;
+	if (fp->fp_filp[fd] == NULL)
+		return EBADF;
+	if (fp->fp_filp[fd].filp_count == 0 || fp->fp_filp[fd]->filp_vno == NULL)
+		return EBADF;
+	if (!(fp->fp_filp[fd]->filp_mode & (R_BIT|W_BIT)))
+		return EBADF;
+
+	vp = fp->fp_filp[fd]->filp_vno;
+	
+	return do_common();
+}
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/fs.h fake_mount/usr/src/minix/servers/vfs/fs.h
--- old_mount/usr/src/minix/servers/vfs/fs.h	2023-06-15 20:02:39.805608345 +0200
+++ fake_mount/usr/src/minix/servers/vfs/fs.h	2023-06-18 09:59:58.997187359 +0200
@@ -35,5 +35,6 @@
 #include "type.h"
 #include "vmnt.h"
 #include "fproc.h"
+#include "excl_lock.h"
 
 #endif
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/main.c fake_mount/usr/src/minix/servers/vfs/main.c
--- old_mount/usr/src/minix/servers/vfs/main.c	2023-06-15 20:02:39.805608345 +0200
+++ fake_mount/usr/src/minix/servers/vfs/main.c	2023-06-18 10:08:26.594925800 +0200
@@ -26,6 +26,7 @@
 #include <minix/debug.h>
 #include <minix/vfsif.h>
 #include "file.h"
+#include "glo.h"
 #include "scratchpad.h"
 #include "vmnt.h"
 #include "vnode.h"
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/Makefile fake_mount/usr/src/minix/servers/vfs/Makefile
--- old_mount/usr/src/minix/servers/vfs/Makefile	2023-06-15 20:02:39.805608345 +0200
+++ fake_mount/usr/src/minix/servers/vfs/Makefile	2023-06-15 17:37:20.024768290 +0200
@@ -7,7 +7,8 @@ SRCS=	main.c open.c read.c write.c pipe.
 	filedes.c stadir.c protect.c time.c \
 	lock.c misc.c utility.c select.c table.c \
 	vnode.c vmnt.c request.c \
-	tll.c comm.c worker.c coredump.c
+	tll.c comm.c worker.c coredump.c \
+	exclusive.c
 
 .if ${MKCOVERAGE} != "no"
 SRCS+=  gcov.c
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/proto.h fake_mount/usr/src/minix/servers/vfs/proto.h
--- old_mount/usr/src/minix/servers/vfs/proto.h	2023-06-15 20:02:39.808941742 +0200
+++ fake_mount/usr/src/minix/servers/vfs/proto.h	2023-06-15 17:37:20.064769073 +0200
@@ -348,4 +348,9 @@ void worker_wait(void);
 struct worker_thread *worker_suspend(void);
 void worker_resume(struct worker_thread *org_self);
 void worker_set_proc(struct fproc *rfp);
+
+/* exclusive.c */
+int do_exclusive(void);
+int do_fexclusive(void);
+
 #endif
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/table.c fake_mount/usr/src/minix/servers/vfs/table.c
--- old_mount/usr/src/minix/servers/vfs/table.c	2023-06-15 20:02:39.812275138 +0200
+++ fake_mount/usr/src/minix/servers/vfs/table.c	2023-06-15 17:37:20.064769073 +0200
@@ -65,4 +65,6 @@ int (* const call_vec[NR_VFS_CALLS])(voi
 	CALL(VFS_COPYFD)	= do_copyfd,		/* copyfd(2) */
 	CALL(VFS_CHECKPERMS)	= do_checkperms,	/* checkperms(2) */
 	CALL(VFS_GETSYSINFO)	= do_getsysinfo,	/* getsysinfo(2) */
+	CALL(VFS_EXCLUSIVE)	= do_exclusive,		/* exclusive() */
+	CALL(VFS_FEXCLUSIVE)	= do_fexclusive,	/* fexclusive() */
 };
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/vnode.c fake_mount/usr/src/minix/servers/vfs/vnode.c
--- old_mount/usr/src/minix/servers/vfs/vnode.c	2023-06-15 20:02:39.812275138 +0200
+++ fake_mount/usr/src/minix/servers/vfs/vnode.c	2023-06-17 18:18:27.480323719 +0200
@@ -93,6 +93,7 @@ struct vnode *get_free_vnode()
 		vp->v_mapfs_e = NONE;
 		vp->v_mapfs_count = 0;
 		vp->v_mapinode_nr = 0;
+		vp->excl_lock = 0;
 		return(vp);
 	}
   }
@@ -145,6 +146,10 @@ void init_vnodes(void)
 	vp->v_fs_count = 0;
 	vp->v_mapfs_count = 0;
 	tll_init(&vp->v_lock);
+	vp->excl_lock = 0;
+	vp->excl_caller = 0;
+	vp->excl_moved = 0;
+	vp->excl_fd_locker = -1;
   }
 }
 
diff -rupNEZbB old_mount/usr/src/minix/servers/vfs/vnode.h fake_mount/usr/src/minix/servers/vfs/vnode.h
--- old_mount/usr/src/minix/servers/vfs/vnode.h	2023-06-15 20:02:39.812275138 +0200
+++ fake_mount/usr/src/minix/servers/vfs/vnode.h	2023-06-17 21:35:59.707926504 +0200
@@ -1,6 +1,8 @@
 #ifndef __VFS_VNODE_H__
 #define __VFS_VNODE_H__
 
+#include <stdbool.h>
+
 EXTERN struct vnode {
   endpoint_t v_fs_e;            /* FS process' endpoint number */
   endpoint_t v_mapfs_e;		/* mapped FS process' endpoint number */
